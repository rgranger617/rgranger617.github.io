<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.5.57">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Robert Granger">

<title>Computational Trick for Harmonic Mean – Robert Granger</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../site_libs/clipboard/clipboard.min.js"></script>
<script src="../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../site_libs/quarto-search/fuse.min.js"></script>
<script src="../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../">
<script src="../site_libs/quarto-html/quarto.js"></script>
<script src="../site_libs/quarto-html/popper.min.js"></script>
<script src="../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../site_libs/quarto-html/anchor.min.js"></script>
<link href="../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../site_libs/quarto-html/quarto-syntax-highlighting.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../site_libs/bootstrap/bootstrap.min.css" rel="stylesheet" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>

  <script src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script>
  <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-chtml-full.js" type="text/javascript"></script>

<script type="text/javascript">
const typesetMath = (el) => {
  if (window.MathJax) {
    // MathJax Typeset
    window.MathJax.typeset([el]);
  } else if (window.katex) {
    // KaTeX Render
    var mathElements = el.getElementsByClassName("math");
    var macros = [];
    for (var i = 0; i < mathElements.length; i++) {
      var texText = mathElements[i].firstChild;
      if (mathElements[i].tagName == "SPAN") {
        window.katex.render(texText.data, mathElements[i], {
          displayMode: mathElements[i].classList.contains('display'),
          throwOnError: false,
          macros: macros,
          fleqn: false
        });
      }
    }
  }
}
window.Quarto = {
  typesetMath
};
</script>

<link rel="stylesheet" href="../styles.css">
</head>

<body class="nav-fixed">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../index.html">
    <span class="navbar-title">Robert Granger</span>
    </a>
  </div>
          <ul class="navbar-nav navbar-nav-scroll me-auto">
  <li class="nav-item">
    <a class="nav-link" href="../index.html"> 
<span class="menu-text">Home</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../about/about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../research/research.html"> 
<span class="menu-text">Research</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../teaching/teaching.html"> 
<span class="menu-text">Teaching</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../information/information.html"> 
<span class="menu-text">Information</span></a>
  </li>  
  <li class="nav-item">
    <a class="nav-link" href="../apps/apps.html"> 
<span class="menu-text">Apps</span></a>
  </li>  
</ul>
          <div class="quarto-navbar-tools">
</div>
            <div id="quarto-search" class="" title="Search"></div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    <div id="quarto-margin-sidebar" class="sidebar margin-sidebar">
        <nav id="TOC" role="doc-toc" class="toc-active">
    <h2 id="toc-title">On this page</h2>
   
  <ul>
  <li><a href="#the-harmonic-mean" id="toc-the-harmonic-mean" class="nav-link active" data-scroll-target="#the-harmonic-mean">The Harmonic Mean</a></li>
  <li><a href="#the-computational-trick" id="toc-the-computational-trick" class="nav-link" data-scroll-target="#the-computational-trick">The Computational Trick</a></li>
  <li><a href="#extending-the-trick-to-compute-the-bayes-factor" id="toc-extending-the-trick-to-compute-the-bayes-factor" class="nav-link" data-scroll-target="#extending-the-trick-to-compute-the-bayes-factor">Extending the Trick to compute the Bayes Factor</a></li>
  <li><a href="#example-computing-the-bf-with-a-normal-distribution" id="toc-example-computing-the-bf-with-a-normal-distribution" class="nav-link" data-scroll-target="#example-computing-the-bf-with-a-normal-distribution">Example: Computing the BF with a normal distribution</a></li>
  <li><a href="#references" id="toc-references" class="nav-link" data-scroll-target="#references">References</a></li>
  </ul>
</nav>
    </div>
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Computational Trick for Harmonic Mean</h1>
<p class="subtitle lead">A Helpful Step in Computing the Bayes Factor</p>
</div>



<div class="quarto-title-meta">

    <div>
    <div class="quarto-title-meta-heading">Author</div>
    <div class="quarto-title-meta-contents">
             <p>Robert Granger </p>
          </div>
  </div>
    
  
    
  </div>
  


</header>


<p>In this article, I derive a <em>computational trick</em> for calculating the harmonic mean when the values of <span class="math inline">\(x_1, x_2, ... x_n\)</span> are too small such that we end up with an <a href="https://en.wikipedia.org/wiki/Arithmetic_underflow">underflow</a> error. The method is a variation of the ubiquitous computational technique for log sum. I then demonstrate the usefulness of this technique by applying it to calculating the Bayes Factor. Throughout this article, code snippets will be provided using <strong>R</strong>.</p>
<section id="the-harmonic-mean" class="level2">
<h2 class="anchored" data-anchor-id="the-harmonic-mean">The Harmonic Mean</h2>
<p>In the early years of schooling and certainly any introductory statistics course, students are taught a handful of measures for <a href="https://en.wikipedia.org/wiki/Central_tendency">central tendency</a>, i.e, computing an <a href="https://en.wikipedia.org/wiki/Average">average</a>. The most common measures being the <a href="https://en.wikipedia.org/wiki/Arithmetic_mean">mean</a>, <a href="https://en.wikipedia.org/wiki/Median">median</a>, and <a href="https://en.wikipedia.org/wiki/Mode_(statistics)">mode</a>. Occasionally, other measures are taught such as the mid-range or the interquartile range, but the aforementioned are by far the most popular. Unknown to many, the mean (specifically the arithmetic mean) that is taught is just one of the three <a href="https://en.wikipedia.org/wiki/Pythagorean_means">Pythagorean means</a> studied by the early Greek mathematicians. The three Pythagorean means are the arithmetic mean, geometric mean, and the harmonic mean.</p>
<p><em>Arithmetic Mean:</em></p>
<p><span class="math display">\[
AM(x_1, x_2, ..., x_n) = \frac{x_1 + x_2 + ... + x_n}{n}
\]</span></p>
<p><em>Geometric Mean:</em></p>
<p><span class="math display">\[
GM(x_1, x_2, ..., x_n) = \sqrt[N]{x_1 \times x_2 \times ... \times x_n}
\]</span></p>
<p><em>Harmonic Mean:</em></p>
<p><span class="math display">\[ HM(x_1, x_2, ..., x_n) = \frac{n}{\frac{1}{x_1} + \frac{1}{x_2} + ... + \frac{1}{x_n}} \]</span></p>
<p>This article focuses on the calculation of the harmonic mean. Calculating the harmonic mean is easy! Suppose we have a rather small dataset, <span class="math inline">\(\boldsymbol{X}\)</span>, with 10 values:</p>
<table class="caption-top table">
<tbody>
<tr class="odd">
<td style="text-align: center;">4</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">1</td>
<td style="text-align: center;">6</td>
<td style="text-align: center;">4</td>
</tr>
<tr class="even">
<td style="text-align: center;">2</td>
<td style="text-align: center;">5</td>
<td style="text-align: center;">9</td>
<td style="text-align: center;">3</td>
<td style="text-align: center;">1</td>
</tr>
</tbody>
</table>
<div class="cell">
<div class="sourceCode cell-code" id="cb1"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a>X <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">6</span>, <span class="dv">4</span>,</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a>      <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">9</span>, <span class="dv">3</span>, <span class="dv">1</span>)</span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>      </span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a>HM <span class="ot">&lt;-</span> <span class="cf">function</span>(data){</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a>  <span class="fu">length</span>(data)<span class="sc">/</span><span class="fu">sum</span>(<span class="dv">1</span><span class="sc">/</span>data)</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">"Harmonic Mean is equal to"</span>, <span class="fu">HM</span>(X)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Harmonic Mean is equal to 2.41286863270777"</code></pre>
</div>
</div>
<p>As we can see, the computation is fairly straightforward, so why are we in need of a trick?</p>
</section>
<section id="the-computational-trick" class="level2">
<h2 class="anchored" data-anchor-id="the-computational-trick">The Computational Trick</h2>
<p>Suppose instead we had a different dataset, <span class="math inline">\(\boldsymbol{Y}\)</span>, such that the values are so small, they can only be tracked through their natural log. This may seem like an odd situation but is fairly common in the realm of statistics as the data may be a listing of joint probabilities. Let the <span class="math inline">\(\log(\boldsymbol{Y})\)</span> be equal to:</p>
<table class="caption-top table">
<tbody>
<tr class="odd">
<td style="text-align: center;">-1000</td>
<td style="text-align: center;">-1001</td>
<td style="text-align: center;">-999</td>
<td style="text-align: center;">-1001</td>
<td style="text-align: center;">-1008</td>
</tr>
<tr class="even">
<td style="text-align: center;">-1006</td>
<td style="text-align: center;">-1000</td>
<td style="text-align: center;">-1000</td>
<td style="text-align: center;">-998</td>
<td style="text-align: center;">-1003</td>
</tr>
</tbody>
</table>
<div class="cell">
<div class="sourceCode cell-code" id="cb3"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1" aria-hidden="true" tabindex="-1"></a>logY <span class="ot">=</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">1000</span>, <span class="sc">-</span><span class="dv">1001</span>, <span class="sc">-</span><span class="dv">999</span>, <span class="sc">-</span><span class="dv">1001</span>, <span class="sc">-</span><span class="dv">1008</span>,</span>
<span id="cb3-2"><a href="#cb3-2" aria-hidden="true" tabindex="-1"></a>         <span class="sc">-</span><span class="dv">1006</span>, <span class="sc">-</span><span class="dv">1000</span>, <span class="sc">-</span><span class="dv">1000</span>, <span class="sc">-</span><span class="dv">998</span>, <span class="sc">-</span><span class="dv">1003</span>)</span>
<span id="cb3-3"><a href="#cb3-3" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-4"><a href="#cb3-4" aria-hidden="true" tabindex="-1"></a>Y <span class="ot">=</span> <span class="fu">exp</span>(logY)</span>
<span id="cb3-5"><a href="#cb3-5" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb3-6"><a href="#cb3-6" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(Y)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] 0 0 0 0 0 0 0 0 0 0</code></pre>
</div>
</div>
<p>Notice that the computer returns “0” for all value of Y in our dataset. This is wrong though as we know the natural log must be strictly positive. If I attempt to get <span class="math inline">\(\boldsymbol{Y}\)</span> back by taking the log,</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb5"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">log</span>(Y))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code> [1] -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf -Inf</code></pre>
</div>
</div>
<p>it now returns all negative infinities instead of our original dataset. The original information of the <span class="math inline">\(\log(\boldsymbol{Y})\)</span> is lost as we have an underflow error. In other words, the value of <span class="math inline">\(\boldsymbol{Y}\)</span> is so close to 0, the computer cannot differentiate it from 0.</p>
<p>Now it should be noted that the harmonic mean of <span class="math inline">\(\boldsymbol{Y}\)</span> is so small it is basically 0 as well. However, just like how we tracked our original data on the natural log scale, it would be advantageous for us to be able to track the harmonic mean on the natural log scale as well. This is of course impossible with our current function for the harmonic mean,</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb7"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">"Harmonic Mean is equal to"</span>, <span class="fu">HM</span>(<span class="fu">exp</span>(logY))))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Harmonic Mean is equal to 0"</code></pre>
</div>
</div>
<p>as we must first take the exponential of the natural log values before adding them together. This in turn would return -infinity for our value of the natural log of the harmonic mean. So… how do we get around this? We begin by writing down the equation for the harmonic mean in terms of the <span class="math inline">\(\log(y_i)\)</span>:</p>
<span class="math display">\[\begin{align}
HM(\boldsymbol{Y}) &amp; = \frac{n}{\frac{1}{\exp(\log(y_1))} + \frac{1}{\exp(\log(y_2))} + ... + \frac{1}{\exp(\log(y_n))}} \\
&amp; = \frac{n}{\exp(-\log(y_1)) + \exp(-\log(y_2)) + ... + \exp(-\log(y_n))} \\
&amp; = \left(\frac{n}{\exp(c-\log(y_1)) + \exp(c-\log(y_2)) + ... + \exp(c-\log(y_n))}\right)\exp(c) \\
\end{align}\]</span>
<p>Now, let’s take the natural log of both sides:</p>
<span class="math display">\[\begin{align}
\log\Big(HM(\boldsymbol{Y})\Big) &amp; = \log(n) + \log(c) - \log\Big(\exp(c-\log(y_1)) + \exp(c-\log(y_2)) + ... + \exp(c-\log(y_n))\Big) \\
\end{align}\]</span>
<p>The equation above no longer requires taking the exponential of <span class="math inline">\(y_i\)</span> but instead the exponential of <span class="math inline">\(c-y_i\)</span> where <span class="math inline">\(c\)</span> is any arbitrary constant. We want to select a <span class="math inline">\(c\)</span> such that we minimize the potential for underflow errors. In this case, the obvious choice is to select <span class="math inline">\(c=\max(\log(\boldsymbol{Y}))\)</span>. I code up the function below and compare it with our <span class="math inline">\(\boldsymbol{X}\)</span> data:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb9"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1" aria-hidden="true" tabindex="-1"></a>logHM <span class="ot">&lt;-</span> <span class="cf">function</span>(logdata){</span>
<span id="cb9-2"><a href="#cb9-2" aria-hidden="true" tabindex="-1"></a>  maxlogdata <span class="ot">=</span> <span class="fu">max</span>(logdata)</span>
<span id="cb9-3"><a href="#cb9-3" aria-hidden="true" tabindex="-1"></a>  N <span class="ot">=</span> <span class="fu">length</span>(logdata)</span>
<span id="cb9-4"><a href="#cb9-4" aria-hidden="true" tabindex="-1"></a>  <span class="fu">log</span>(N) <span class="sc">+</span> maxlogdata <span class="sc">-</span> <span class="fu">log</span>(<span class="fu">sum</span>(<span class="fu">exp</span>(maxlogdata<span class="sc">-</span>logdata)))</span>
<span id="cb9-5"><a href="#cb9-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb9-6"><a href="#cb9-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb9-7"><a href="#cb9-7" aria-hidden="true" tabindex="-1"></a><span class="do">### Original Method without computational trick</span></span>
<span id="cb9-8"><a href="#cb9-8" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">"Log Harmonic Mean is equal to"</span>, <span class="fu">log</span>(<span class="fu">HM</span>(X))))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Log Harmonic Mean is equal to 0.880816343680495"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb11"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb11-1"><a href="#cb11-1" aria-hidden="true" tabindex="-1"></a><span class="do">### New Method using computation trick</span></span>
<span id="cb11-2"><a href="#cb11-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">"Log Harmonic Mean is equal to"</span>, <span class="fu">logHM</span>(<span class="fu">log</span>(X))))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Log Harmonic Mean is equal to 0.880816343680495"</code></pre>
</div>
</div>
<p>As expected, the two methods return the exact same value. Now, let’s run it on the <span class="math inline">\(\boldsymbol{Y}\)</span> dataset:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb13"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb13-1"><a href="#cb13-1" aria-hidden="true" tabindex="-1"></a><span class="do">### Original Method without computational trick</span></span>
<span id="cb13-2"><a href="#cb13-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">"Log Harmonic Mean is equal to"</span>, <span class="fu">log</span>(<span class="fu">HM</span>(Y))))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Log Harmonic Mean is equal to -Inf"</code></pre>
</div>
<div class="sourceCode cell-code" id="cb15"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb15-1"><a href="#cb15-1" aria-hidden="true" tabindex="-1"></a><span class="do">### New Method using computation trick</span></span>
<span id="cb15-2"><a href="#cb15-2" aria-hidden="true" tabindex="-1"></a><span class="fu">print</span>(<span class="fu">paste</span>(<span class="st">"Log Harmonic Mean is equal to"</span>, <span class="fu">logHM</span>(logY)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] "Log Harmonic Mean is equal to -1005.83288259162"</code></pre>
</div>
</div>
<p>While the simple, direct computation failed with a return of “-Inf”, the new method using the computational trick was able to successfully compute the log harmonic mean.</p>
</section>
<section id="extending-the-trick-to-compute-the-bayes-factor" class="level2">
<h2 class="anchored" data-anchor-id="extending-the-trick-to-compute-the-bayes-factor">Extending the Trick to compute the Bayes Factor</h2>
<p>The goal of almost every Bayesian statistics problem is to determine the posterior distribution of some model parameters, <span class="math inline">\(\theta\)</span>,</p>
<p><span class="math display">\[
p(\theta|data) = \frac{p(data|\theta)p(\theta)}{p(data)}.
\]</span></p>
<p>For example, if you have some data that you believe comes from a normal distribution, you may want to understand it’s mean and variance, so <span class="math inline">\(\theta = [\mu,\sigma^2]\)</span>. Essentially, we start with some prior information on the parameters, <span class="math inline">\(p(\theta)\)</span>, and update that information with our data likelihood, <span class="math inline">\(p(data|\theta)\)</span>, and obtain our posterior estimate, <span class="math inline">\(p(\theta|data)\)</span>. The denominator of our equation, <span class="math inline">\(p(data)\)</span>, is called the <strong><em>marginal data likelihood</em></strong> and is often avoided in calculations by taking advantage of conjugacy or normalization if discrete.</p>
<p>Unfortuantely, the posterior distribution is subject to constraints imposed by different model choices. A common approach to model selection using Bayesian statistics is through the calculation of the Bayes Factor. The Bayes Factor is simply the odds ratio of obtaining the observed data given two models, <span class="math inline">\(M1\)</span>, and <span class="math inline">\(M2\)</span>:</p>
<p><span class="math display">\[
BF(M1,M2) = \frac{p(data|M1)}{p(data|M2)}
\]</span></p>
<p>Notice, the Bayes Factor is the ratio of the marginal data likelihoods of the two models. The reason this term is often avoided is do to the challenge in it’s calculation as it is the probability of obtaining the data integrated across all parameters.</p>
<p><span class="math display">\[
p(data|M_j) = \int p(data|\theta,M_j)p(\theta)d\theta
\]</span></p>
<p>Nevertheless, (<a href="https://www.jstor.org/stable/2346025">Newton and Raftery 1994</a>) show that we can approximate the marginal data likelihood using samples from the posterior distribution <span class="math inline">\(p(data|\theta,Mi)\)</span> through the harmonic mean.</p>
<p><span class="math display">\[
\hat{p}(data|M_j) = \frac{n}{\sum_{i=1}^n \frac{1}{p(data|\theta_i,Mj)}+\frac{1}{p(data|\theta_i,Mj)}+...\frac{1}{p(data|\theta_i,Mj)}}
\]</span></p>
<p>We can therefore use our computational trick for the harmonic mean to obtain the log of the marginal data likelihood of both models, <span class="math inline">\(M_1\)</span> and <span class="math inline">\(M_2\)</span>. We can then compute the log of the Bayes Factor,</p>
<p><span class="math display">\[
\log\Big(BF(M_1,M_2)\Big) = \log\Big(p(data|M_1)\Big) - \log\Big(p(data|M_2)\Big),
\]</span></p>
<p>and then just take the exponential when we’re all done to get the Bayes Factor.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb17"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb17-1"><a href="#cb17-1" aria-hidden="true" tabindex="-1"></a>BF12 <span class="ot">&lt;-</span> <span class="cf">function</span>(logdata1,logdata2){</span>
<span id="cb17-2"><a href="#cb17-2" aria-hidden="true" tabindex="-1"></a>  maxlogdata1 <span class="ot">=</span> <span class="fu">max</span>(logdata1); maxlogdata2 <span class="ot">=</span> <span class="fu">max</span>(logdata2)</span>
<span id="cb17-3"><a href="#cb17-3" aria-hidden="true" tabindex="-1"></a>  N1 <span class="ot">=</span> <span class="fu">length</span>(logdata1);N2 <span class="ot">=</span> <span class="fu">length</span>(logdata2)</span>
<span id="cb17-4"><a href="#cb17-4" aria-hidden="true" tabindex="-1"></a>  logpdata1 <span class="ot">=</span> <span class="fu">log</span>(N1) <span class="sc">+</span> maxlogdata1 <span class="sc">-</span> <span class="fu">log</span>(<span class="fu">sum</span>(<span class="fu">exp</span>(maxlogdata1<span class="sc">-</span>logdata1)))</span>
<span id="cb17-5"><a href="#cb17-5" aria-hidden="true" tabindex="-1"></a>  logpdata2 <span class="ot">=</span> <span class="fu">log</span>(N2) <span class="sc">+</span> maxlogdata2 <span class="sc">-</span> <span class="fu">log</span>(<span class="fu">sum</span>(<span class="fu">exp</span>(maxlogdata2<span class="sc">-</span>logdata2)))</span>
<span id="cb17-6"><a href="#cb17-6" aria-hidden="true" tabindex="-1"></a>  <span class="fu">exp</span>(logpdata1 <span class="sc">-</span> logpdata2)</span>
<span id="cb17-7"><a href="#cb17-7" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>And let’s just generate some data to test this function.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb18"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb18-1"><a href="#cb18-1" aria-hidden="true" tabindex="-1"></a>X1 <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">4</span>, <span class="dv">3</span>, <span class="dv">1</span>, <span class="dv">6</span>, <span class="dv">4</span>,</span>
<span id="cb18-2"><a href="#cb18-2" aria-hidden="true" tabindex="-1"></a>       <span class="dv">2</span>, <span class="dv">5</span>, <span class="dv">9</span>, <span class="dv">3</span>, <span class="dv">1</span>)</span>
<span id="cb18-3"><a href="#cb18-3" aria-hidden="true" tabindex="-1"></a>X2 <span class="ot">=</span> <span class="fu">c</span>(<span class="dv">3</span>, <span class="dv">3</span>, <span class="dv">2</span>, <span class="dv">2</span>, <span class="dv">2</span>,</span>
<span id="cb18-4"><a href="#cb18-4" aria-hidden="true" tabindex="-1"></a>       <span class="dv">1</span>, <span class="dv">5</span>, <span class="dv">1</span>, <span class="dv">7</span>, <span class="dv">7</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb19"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb19-1"><a href="#cb19-1" aria-hidden="true" tabindex="-1"></a><span class="do">### No Computational Trick</span></span>
<span id="cb19-2"><a href="#cb19-2" aria-hidden="true" tabindex="-1"></a><span class="fu">HM</span>(X1)<span class="sc">/</span><span class="fu">HM</span>(X2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1.122558</code></pre>
</div>
<div class="sourceCode cell-code" id="cb21"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb21-1"><a href="#cb21-1" aria-hidden="true" tabindex="-1"></a><span class="do">### Computational Trick</span></span>
<span id="cb21-2"><a href="#cb21-2" aria-hidden="true" tabindex="-1"></a><span class="fu">BF12</span>(<span class="fu">log</span>(X1),<span class="fu">log</span>(X2))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1.122558</code></pre>
</div>
</div>
<p>And now let’s generate some very small data that needs to be represented by the natural log:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb23"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb23-1"><a href="#cb23-1" aria-hidden="true" tabindex="-1"></a>logY1 <span class="ot">=</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">1000</span>, <span class="sc">-</span><span class="dv">1000</span>, <span class="sc">-</span><span class="dv">1001</span>, <span class="sc">-</span><span class="dv">1003</span>, <span class="sc">-</span><span class="dv">999</span>,</span>
<span id="cb23-2"><a href="#cb23-2" aria-hidden="true" tabindex="-1"></a>          <span class="sc">-</span><span class="dv">1010</span>, <span class="sc">-</span><span class="dv">1002</span>, <span class="sc">-</span><span class="dv">1004</span>, <span class="sc">-</span><span class="dv">1003</span>, <span class="sc">-</span><span class="dv">998</span>)</span>
<span id="cb23-3"><a href="#cb23-3" aria-hidden="true" tabindex="-1"></a>logY2 <span class="ot">=</span> <span class="fu">c</span>(<span class="sc">-</span><span class="dv">1001</span>, <span class="sc">-</span><span class="dv">1009</span>, <span class="sc">-</span><span class="dv">1007</span>, <span class="sc">-</span><span class="dv">1003</span>, <span class="sc">-</span><span class="dv">997</span>,</span>
<span id="cb23-4"><a href="#cb23-4" aria-hidden="true" tabindex="-1"></a>          <span class="sc">-</span><span class="dv">1010</span>, <span class="sc">-</span><span class="dv">1002</span>, <span class="sc">-</span><span class="dv">1002</span>, <span class="sc">-</span><span class="dv">1002</span>, <span class="sc">-</span><span class="dv">999</span>)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb24"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb24-1"><a href="#cb24-1" aria-hidden="true" tabindex="-1"></a><span class="do">### No Computational Trick</span></span>
<span id="cb24-2"><a href="#cb24-2" aria-hidden="true" tabindex="-1"></a><span class="fu">HM</span>(<span class="fu">exp</span>(logY1))<span class="sc">/</span><span class="fu">HM</span>(<span class="fu">exp</span>(logY2))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] NaN</code></pre>
</div>
<div class="sourceCode cell-code" id="cb26"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb26-1"><a href="#cb26-1" aria-hidden="true" tabindex="-1"></a><span class="do">### Computational Trick</span></span>
<span id="cb26-2"><a href="#cb26-2" aria-hidden="true" tabindex="-1"></a><span class="fu">BF12</span>(logY1,logY2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 1.41284</code></pre>
</div>
</div>
<p>Once again, we see the importance of this computational trick as the naive, direct computation fails.</p>
</section>
<section id="example-computing-the-bf-with-a-normal-distribution" class="level2">
<h2 class="anchored" data-anchor-id="example-computing-the-bf-with-a-normal-distribution">Example: Computing the BF with a normal distribution</h2>
<p>In this section, let’s look at an actual example where we generate samples from our posterior using a Monte Carlo simulation. Suppose you generate 500 observations from a normal distribution with mean, <span class="math inline">\(\mu=10\)</span>, and variance, <span class="math inline">\(\sigma^2 = 3\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb28"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb28-1"><a href="#cb28-1" aria-hidden="true" tabindex="-1"></a>m <span class="ot">=</span> <span class="dv">500</span></span>
<span id="cb28-2"><a href="#cb28-2" aria-hidden="true" tabindex="-1"></a>MU <span class="ot">=</span> <span class="dv">10</span></span>
<span id="cb28-3"><a href="#cb28-3" aria-hidden="true" tabindex="-1"></a>SIGMA2 <span class="ot">=</span> <span class="dv">3</span></span>
<span id="cb28-4"><a href="#cb28-4" aria-hidden="true" tabindex="-1"></a>X <span class="ot">=</span> <span class="fu">rnorm</span>(m, MU, <span class="fu">sqrt</span>(SIGMA2))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Let’s take a look at this data:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb29"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb29-1"><a href="#cb29-1" aria-hidden="true" tabindex="-1"></a><span class="fu">hist</span>(X)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output-display">
<div>
<figure class="figure">
<p><img src="BFcomptrick_files/figure-html/unnamed-chunk-10-1.png" class="img-fluid figure-img" width="672"></p>
</figure>
</div>
</div>
</div>
<p>You show the following histogram to two of your friends, Daniel and Brandon. We are interested in developing a model where we can predict the mean, <span class="math inline">\(\mu\)</span>, but want a fixed variance, <span class="math inline">\(\sigma^2\)</span>. Daniel (<span class="math inline">\(M_1\)</span>) looks at the histogram and proposes that the variance should be fixed at <span class="math inline">\(\sigma^2=3.0\)</span>. Brandon (<span class="math inline">\(M_2\)</span>), on the other hand, looks at the histogram and thinks the variance is <span class="math inline">\(\sigma^2=2.5\)</span>. Which of your friends has proposed the better model?</p>
<p>Since the variance, <span class="math inline">\(\sigma^2\)</span> is fixed, we can simply write our posterior as:</p>
<p><span class="math display">\[
p(\mu|X,M_j) = \frac{p(X|\mu,M_j)p(\mu,M_j)}{p(X|M_j)}
\]</span> To ensure an easy to compute posterior, we use a normal prior, <span class="math inline">\(p(\mu)=Normal(0,1)\)</span>. This results in a conjugate posterior normal distribution,</p>
<p><span class="math display">\[
p(\mu|X,M_j) = Normal\left(\frac{m\bar{X}}{\sigma^2+m},\frac{\sigma^2}{\sigma^2+m}\right)
\]</span> where <span class="math inline">\(m\)</span> is the number of observations and <span class="math inline">\(\bar{X}\)</span> is the mean of these observations. (See pg 41 of <a href="https://stat.columbia.edu/~gelman/book/">Gelman et. al.&nbsp;2014</a> for this solution)</p>
<p>Now that we know the posterior distribution, we can draw samples from it by sampling from this distribution.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb30"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb30-1"><a href="#cb30-1" aria-hidden="true" tabindex="-1"></a>samples <span class="ot">=</span> <span class="dv">10000</span></span>
<span id="cb30-2"><a href="#cb30-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-3"><a href="#cb30-3" aria-hidden="true" tabindex="-1"></a><span class="do">### Model 1 (Daniel)</span></span>
<span id="cb30-4"><a href="#cb30-4" aria-hidden="true" tabindex="-1"></a>SIGMA2M1 <span class="ot">=</span> <span class="fl">3.0</span></span>
<span id="cb30-5"><a href="#cb30-5" aria-hidden="true" tabindex="-1"></a>posteriorMUM1 <span class="ot">=</span> <span class="fu">rnorm</span>(samples, m<span class="sc">*</span><span class="fu">mean</span>(X)<span class="sc">/</span>(SIGMA2M1<span class="sc">+</span>m),<span class="fu">sqrt</span>(SIGMA2M1<span class="sc">/</span>(SIGMA2M1<span class="sc">+</span>m)))</span>
<span id="cb30-6"><a href="#cb30-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-7"><a href="#cb30-7" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb30-8"><a href="#cb30-8" aria-hidden="true" tabindex="-1"></a><span class="do">### Model 2 (Brandon)</span></span>
<span id="cb30-9"><a href="#cb30-9" aria-hidden="true" tabindex="-1"></a>SIGMA2M2 <span class="ot">=</span> <span class="fl">2.8</span></span>
<span id="cb30-10"><a href="#cb30-10" aria-hidden="true" tabindex="-1"></a>posteriorMUM2 <span class="ot">=</span> <span class="fu">rnorm</span>(samples, m<span class="sc">*</span><span class="fu">mean</span>(X)<span class="sc">/</span>(SIGMA2M2<span class="sc">+</span>m),<span class="fu">sqrt</span>(SIGMA2M2<span class="sc">/</span>(SIGMA2M2<span class="sc">+</span>m)))</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>After obtaining 10,000 samples from the posterior, the data likelihood at each sample can be computed via <span class="math inline">\(p(data|\theta) = p(X|\mu) = \prod_{i=1}^m Normal(x_i|\mu)\)</span>.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb31"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb31-1"><a href="#cb31-1" aria-hidden="true" tabindex="-1"></a>mlikeM1 <span class="ot">=</span> <span class="fu">rep</span>(<span class="cn">NA</span>,samples)</span>
<span id="cb31-2"><a href="#cb31-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(samp <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>samples){</span>
<span id="cb31-3"><a href="#cb31-3" aria-hidden="true" tabindex="-1"></a>  MUsamp <span class="ot">=</span> posteriorMUM1[samp]</span>
<span id="cb31-4"><a href="#cb31-4" aria-hidden="true" tabindex="-1"></a>  mlikeM1[samp] <span class="ot">=</span> <span class="fu">prod</span>(<span class="fu">dnorm</span>(X,MUsamp,<span class="fu">sqrt</span>(SIGMA2M1)))</span>
<span id="cb31-5"><a href="#cb31-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb31-6"><a href="#cb31-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb31-7"><a href="#cb31-7" aria-hidden="true" tabindex="-1"></a>mlikeM2 <span class="ot">=</span> <span class="fu">rep</span>(<span class="cn">NA</span>,samples)</span>
<span id="cb31-8"><a href="#cb31-8" aria-hidden="true" tabindex="-1"></a>mloglikeM2 <span class="ot">=</span> <span class="fu">rep</span>(<span class="cn">NA</span>,samples)</span>
<span id="cb31-9"><a href="#cb31-9" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(samp <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>samples){</span>
<span id="cb31-10"><a href="#cb31-10" aria-hidden="true" tabindex="-1"></a>  MUsamp <span class="ot">=</span> posteriorMUM1[samp]</span>
<span id="cb31-11"><a href="#cb31-11" aria-hidden="true" tabindex="-1"></a>  mlikeM2[samp] <span class="ot">=</span> <span class="fu">prod</span>(<span class="fu">dnorm</span>(X,MUsamp,<span class="fu">sqrt</span>(SIGMA2M2)))</span>
<span id="cb31-12"><a href="#cb31-12" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<p>Then compute the Bayes Factor by taking the ratio of harmonic means of the data likelihoods:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb32"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb32-1"><a href="#cb32-1" aria-hidden="true" tabindex="-1"></a><span class="fu">HM</span>(mlikeM1)<span class="sc">/</span><span class="fu">HM</span>(mlikeM2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] NaN</code></pre>
</div>
</div>
<p>Oh no! It returned NaN! Something has gone wrong. Let’s look at the the first 5 likelihood values from each of our samples:</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb34"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb34-1"><a href="#cb34-1" aria-hidden="true" tabindex="-1"></a><span class="fu">head</span>(mlikeM1); <span class="fu">head</span>(mlikeM2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0 0 0 0 0 0</code></pre>
</div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 0 0 0 0 0 0</code></pre>
</div>
</div>
<p>All of the values are being reported as 0, but this is not possible as we’re multiply a bunch of terms that are all strictly greater than 0 (albeit very small). It looks like we’re experiencing an underflow issue. Let’s instead compute the log likelihoods and use our computational trick.</p>
<div class="cell">
<div class="sourceCode cell-code" id="cb37"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb37-1"><a href="#cb37-1" aria-hidden="true" tabindex="-1"></a>mloglikeM1 <span class="ot">=</span> <span class="fu">rep</span>(<span class="cn">NA</span>,samples)</span>
<span id="cb37-2"><a href="#cb37-2" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(samp <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>samples){</span>
<span id="cb37-3"><a href="#cb37-3" aria-hidden="true" tabindex="-1"></a>  MUsamp <span class="ot">=</span> posteriorMUM1[samp]</span>
<span id="cb37-4"><a href="#cb37-4" aria-hidden="true" tabindex="-1"></a>  mloglikeM1[samp] <span class="ot">=</span> <span class="fu">sum</span>(<span class="fu">dnorm</span>(X,MUsamp,<span class="fu">sqrt</span>(SIGMA2M1),<span class="at">log=</span><span class="cn">TRUE</span>))</span>
<span id="cb37-5"><a href="#cb37-5" aria-hidden="true" tabindex="-1"></a>}</span>
<span id="cb37-6"><a href="#cb37-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb37-7"><a href="#cb37-7" aria-hidden="true" tabindex="-1"></a>mloglikeM2 <span class="ot">=</span> <span class="fu">rep</span>(<span class="cn">NA</span>,samples)</span>
<span id="cb37-8"><a href="#cb37-8" aria-hidden="true" tabindex="-1"></a><span class="cf">for</span>(samp <span class="cf">in</span> <span class="dv">1</span><span class="sc">:</span>samples){</span>
<span id="cb37-9"><a href="#cb37-9" aria-hidden="true" tabindex="-1"></a>  MUsamp <span class="ot">=</span> posteriorMUM1[samp]</span>
<span id="cb37-10"><a href="#cb37-10" aria-hidden="true" tabindex="-1"></a>  mloglikeM2[samp] <span class="ot">=</span> <span class="fu">sum</span>(<span class="fu">dnorm</span>(X,MUsamp,<span class="fu">sqrt</span>(SIGMA2M2),<span class="at">log=</span><span class="cn">TRUE</span>))</span>
<span id="cb37-11"><a href="#cb37-11" aria-hidden="true" tabindex="-1"></a>}</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
</div>
<div class="cell">
<div class="sourceCode cell-code" id="cb38"><pre class="sourceCode r code-with-copy"><code class="sourceCode r"><span id="cb38-1"><a href="#cb38-1" aria-hidden="true" tabindex="-1"></a><span class="fu">BF12</span>(mloglikeM1,mloglikeM2)</span></code><button title="Copy to Clipboard" class="code-copy-button"><i class="bi"></i></button></pre></div>
<div class="cell-output cell-output-stdout">
<pre><code>[1] 4.323865</code></pre>
</div>
</div>
<p>We have successfully avoided the underflow issue and computed the Bayes Factor. Since we created the data, we know the better model was Daniel’s as he proposed the true variance, <span class="math inline">\(\sigma^2=3\)</span>. If we didn’t create the data though, we could have made this conclusion though since the Bayes Factor is greater than 1, indicating <span class="math inline">\(M_1\)</span> is the better fit. Without this computational trick, we would not have been able to solve for the Bayes Factor and reach this conclusion.</p>
<p>I make one final note to users of this method. While we demonstrated the usefulness of this computational trick, we did not show the usefulness of estimating the marginal likelihood via the harmonic mean. It is a very simple technique; however, it tends to be highly unstable and requires a very large sample size. Nevertheless, I have found that for answering the binary question of which model is better, it does quite well; however, the true Bayes factor is typically considerably off from the value obtained via this procedure.</p>
</section>
<section id="references" class="level2">
<h2 class="anchored" data-anchor-id="references">References</h2>
<p><a href="https://stat.columbia.edu/~gelman/book/">Gelman, A., Carlin, J. B., Stern, H. S., Dunson, D. B., Vehtari, A., and Rubin, D. B. (2014). Bayesian Data Analysis. Chapman &amp; Hall/CRC, third edition.</a></p>
<p><a href="https://www.jstor.org/stable/2346025">Newton, M. A. Raftery, A.E. (1994). Approximate Bayesian Inference with the Weighted Likelihood Bootstrap. Journal of the Royal Statistical Society: Series B (Methodological), 56(1):3-26.</a></p>


</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    // For code content inside modals, clipBoardJS needs to be initialized with a container option
    // TODO: Check when it could be a function (https://github.com/zenorocha/clipboard.js/issues/860)
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp('/' + window.location.host + '/');
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'quarto',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      // TODO in 1.5, we should make sure this works without a callout special case
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
      &nbsp;
    </div>   
    <div class="nav-footer-center">
<p><a href="mailto:rgranger@iu.edu"><i class="bi bi-envelope"></i></a> <a href="https://www.linkedin.com/in/rgranger617"><i class="bi bi-linkedin"></i></a> <a href="https://twitter.com/rgranger617"><i class="bi bi-twitter"></i></a> <a href="https://github.com/rgranger617"><i class="bi bi-github"></i></a></p>
</div>
    <div class="nav-footer-right">
<p>© 2022, Robert E. Granger</p>
</div>
  </div>
</footer>




</body></html>